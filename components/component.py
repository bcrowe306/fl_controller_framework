from ..controls.control import Control, ControlBase
from ..core.event import GlobalEventObject, EventObject
from ..core.state import StateBase
from ..api.fl_class import _fl

class Component(StateBase, EventObject):
    """A base class that is used to group controls together to provide functionality. For example, you would create a TransportComponent by inheriting from this class.
        It has all the functionality to activate and deactivate controls, along with decorator functions for listening to control events, and FL studio generated events.
        A component makes it easy to group controls together and activate and deactivate them when necessary. Using this method you can create components for any functionality.
        When inheriting from this class, create as many controls as necessary as instance objects, use the Component.subscribe(), and Component.listens() decorators to react to those controls and FL events, and program you login in various methods.
    """
    @staticmethod
    def listens(event_path: str):
        """A static method the is used to listen to FL studio event and react to them by the function they are decorating. Upon component activation, each function that is decorated with Component.listens() will be registered in the global event object.
            Example: Component.listens("channels.selectedChannel"). This decorator will call the decorated function each time channels.selectedChannel is changed.
        """
        def dec(func):
            func.event_path = event_path
            return func
        return dec
    
    @staticmethod
    def subscribe(control_name: str, event: str):
        """A static method that is used to subscribe functions to a Control on the Component instance. Upon component activation, each function that is decorated with Component.subscribe will be subscribed using the global event object.
            This is how you listen to and react to event generated by controls. Example: Component.subscribe("play_button", "pressed" )"""
        def dec(func):
            func.control_name = control_name
            func.control_event = event
            return func
        return dec

    def __init__(self, name: str, auto_active: bool = True, *a, **k):
        super(Component, self).__init__(*a, **k)
        self.name: str = name
        """Component Name: Must be unique. The name is used when publishing events from this component."""
        self.global_event_object: GlobalEventObject = GlobalEventObject()
        """A reference to the global event registry"""
        self.auto_active: bool = auto_active
        "Whether or not to automatically activate this component upon declaration"
        self.fl: _fl = _fl
        """FL Studio modules object: This object hold a reference to all Fl Studio modules and functions."""

    def notify(self, event_name: str, *a, **k):
        """Helper method to publish event sourced form this component. The event_id is component_name.event. This is useful for communication between components if you need."""
        self.global_event_object.notify_listeners(
            '{}.{}'.format(self.name, event_name), *a, **k)

    def _control_subscribe(self):
        """Finds each function with the Decorator @Component.subscribe(control_name: str, event_id: str). Once found it binds the function to the control event specified in the decorator.
        It does this with the global event object. This is called at Component activation at Component.activate()"""
        for attr in dir(self):
            func = getattr(self, attr)
            if hasattr(func, 'control_event') and hasattr(func, 'control_name'):
                control_event = func.control_event
                instance_control_name = func.control_name

                # Get the control that was passed into the Component instance, and subscribe to it's events
                if hasattr(self, instance_control_name) and isinstance(getattr(self, func.control_name), ControlBase):
                    control: ControlBase = getattr(self, func.control_name)
                    if control is not None:
                        self.global_event_object.subscribe('{}.{}'.format(control.name, control_event), func)

    def _control_unsubscribe(self):
        """Finds each function with the Decorator @Component.subscribe(control_name: str, event_id: str). Once found it unsubscribes the function to the control event specified in the decorator.
        It does on the global event object. This is called at deactivation with Component.deactivate()"""
        for attr in dir(self):
            func = getattr(self, attr)
            if hasattr(func, 'control_event') and hasattr(func, 'control_name'):
                control_event = func.control_event
                instance_control_name = func.control_name

                # Get the control that was passed into the Component instance, and unsubscribe to it's events
                if hasattr(self, instance_control_name) and isinstance(getattr(self, func.control_name), ControlBase):
                    control: ControlBase = getattr(self, func.control_name)
                    if control is not None:
                        self.global_event_object.unsubscribe('{}.{}'.format(control.name, control_event), func)

    def _get_observers(self):
        """Get all functions on this Component instance that are decorated with @Component.listens(). """
        local_scope_observers = dict()
        for attr in dir(self):
            func = getattr(self, attr)
            if hasattr(func, 'event_path'):
                event_path = func.event_path
                if local_scope_observers.get(event_path) == None:
                    local_scope_observers[event_path] = []
                    local_scope_observers[event_path].append(func)
                else:
                    if func not in local_scope_observers[event_path]:
                        local_scope_observers[event_path].append(func)
        return local_scope_observers

    def _get_controls(self):
        """Gets all controls on this Component instance"""
        controls = dict()
        for attr in dir(self):
            control = getattr(self, attr)
            if isinstance(control, ControlBase):
                controls[attr] = control
        return controls

    def add_control_subscribe(self, control_name: str,  control: ControlBase, control_event: str, func):
        """Add a control and subscribe to a control event in one method call. This is useful if you want to add controls and functionality to a Component outside of the Component class.
            This function will attach the control to the component object if it is not already attached, and subscribe to the event.
            It will also attach the function to the component object if it is not already attached. 
            If a lambda function is passed, the __name__ attribute will be set to "on_control_name_event_name" pattern. Otherwise, the function name will be used.
            This means, if you call this method multiple times with the same control_name and control_event, and passing a lambda as the func arg, the function will be overwritten.
        """

        # Check if control already exists on the component object
        if not hasattr(self, control_name):
            setattr(self, control_name, control)

        self.subscribe_control(control_name, control_event, func)

    def subscribe_control(self, control_name: str, control_event: str, func):
        """Subscribe to a control event. This is useful if you want to subscribe to a control event outside of the Component class.
        This method will attach the function to the component object if it is not already attached using the "on_control_name_event_name" pattern.
        If a lambda function is passed, the __name__ attribute will be set to "on_control_name_event_name" pattern. Otherwise, the function name will be used.
        This means, if you call this method multiple times with the same control_name and control_event, and passing a lambda as the func arg, the function will be overwritten.
        """

        func_name: str = f"on_{control_name}_{control_event}" if func.__name__ == "<lambda>" else func.__name__
        setattr(func, "control_event", control_event)
        setattr(func, "control_name", control_name)
        setattr(self, func_name, func)
        
    def listens_event(self, event_path: str, func):
        """Listen to an event. This is useful if you want to listen to an event outside of the Component class.
        This method will attach the function to the component object if it is not already attached using the "on_event_path" pattern.
        If a lambda function is passed, the __name__ attribute will be set to "on_event_path" pattern. Otherwise, the function name will be used.
        This means, if you call this method multiple times with the same event_path, and passing a lambda as the func arg, the function will be overwritten.
        """
        func_name: str = f"on_{event_path}" if func.__name__ == "<lambda>" else func.__name__
        setattr(func, "event_path", event_path)
        setattr(self, func_name, func)

    def activate(self):
        """Activate this Component and all its controls. This method also subscribes to all control events listed in the Component.subscribe(decorator, and register all functions decorated with Component.listens()) """
        if self.isChanged('active', True):

            # Activation Hook
            self.before_activate()
            # Activate each control instance of this component
            self._control_subscribe()
            controls = self._get_controls()
            for control_key in controls:
                control: ControlBase = controls[control_key]
                if control is not None:
                    control.activate()

            # Bind listener functions to event_path in main event loop
            observers = self._get_observers()
            for event_path in observers:
                for func in observers[event_path]:
                    self.global_event_object.subscribe(event_path, func)

            # Activation Hook
            self.after_activate()

    def deactivate(self):
        """Deactivate this Component and all its controls. This method also unsubscribes to all control events listed in the Component.subscribe(decorator, and unregister all functions decorated with Component.listens()) """
        if self.isChanged('active', False):
            # Deactivate Controls

            # Deactivation Hook
            self.before_deactivate()
            self._control_unsubscribe()
            controls: list[Control] = self._get_controls()
            for control_key in controls:
                control: ControlBase = controls[control_key]
                if control is not None:
                    control.deactivate()

            # Unbind listener functions from event_path
            observers = self._get_observers()
            for event_path in observers:
                for func in observers[event_path]:
                    self.global_event_object.unsubscribe(event_path, func)
            
            # Deactivation Hook 
            self.after_deactivate()
    
    def before_activate(self):
        """This method is called before the component is activated. It is useful for setting up the component before activation."""
        pass

    def after_activate(self):
        """This method is called before the component is activated. It is useful for setting up the component before activation."""
        pass

    def before_deactivate(self):
        """This method is called before the component is deactivated. It is useful for cleaning up the component before deactivation."""
        pass

    def after_deactivate(self):
        """This method is called after the component is deactivated. It is useful for cleaning up the component after deactivation."""
        pass

    def blackout(self):
        """Turn off all controls on this component"""
        controls = self._get_controls()
        for control_key in controls:
            control: ControlBase = controls[control_key]
            if control is not None:
                control.blackout()
