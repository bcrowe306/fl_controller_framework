from ..core.control_registry import ControlRegistry
from ..util.midi import MIDI_STATUS
from ..core.skin import SkinColor
from ..core.event import EventObject, GlobalEventObject
from ..core.state import StateBase
from uuid import uuid4
import device

class ControlBase(EventObject, StateBase):
    """This class is the base class for the control object. It has the methods that should be implemented by any control the inherits from it. It is not to be used directly."""
    def __init__(self, name: str, channel: int, identifier: int, status=MIDI_STATUS.NOTE_ON_STATUS, playable=False, *a, **k):
        super(ControlBase, self).__init__(*a, **k)
        self.uuid: str = str(uuid4())
        self.device = device
        """This is the FL Studio device module. It allows you to send midi messages directly from the control."""
        self.name: str = name
        """Name of the control. Must be unique. The name of the control is used to identify and subscribe to events generated by the control."""
        self.status: int = status
        """This is the status byte of the midi msg. The default is a midi note state. Do not include the full status byte with the channel bits."""
        self.channel: int = channel
        """Midi Channel the control is registered to. 0-15"""
        self.identifier: int = identifier
        """Midi Data1 of the Midi message. This is the note/CC the control transmits on. 
        Valid input = 0-127. 
        Example: identifier=0, "This would note C0" """
        self.playable: bool = playable
        """Is this control playable. This will determine if the values sent by this control are forwarded into FL Studio for playing devices."""
        self.event_object: GlobalEventObject = GlobalEventObject()
        """Global Event Object"""
        self.registry: ControlRegistry = ControlRegistry()
        """Global Control Registry"""


    def notify(self, event_name: str, *a, **k):
        """Alias convenience method for self.event_object.notify_listeners. Calling this method automatically prefixed the event name with the name of the control."""
        self.event_object.notify_listeners(
            '{}.{}'.format(self.name, event_name), *a, **k)

    def broadcast(self, event_name: str, *a, **k):
        """Alias convenience method for self.event_object.notify_listeners. Calling this method send a notification without prefixing the controller's name to the front."""
        self.event_object.notify_listeners(event_name, * a, **k)

    def activate(self):
        """Override Method. Inheriting classes should override this method. This method is called by the component it is attached to when the component activates."""
        pass

    def deactivate(self):
        """Override Method. Inheriting classes should override this method. This method is called by the component it is attached to when the component activates."""
        pass

    def _on_value(self, event):
        """Override Method: Inheriting classes should override this method. This is the function that is bound to value events sent by the control."""
        pass

    def reset(self):
        """Override Method: Inheriting classes should override this method.. This resets the control to default state."""
        pass

    def blackout(self):
        """Override Method: Inheriting classes should override this method.. This turns the the control to blackout state."""
        pass

    def __str__(self) -> str:
        return f"{self.name} {self.channel} {self.identifier} {self.status}"

# TODO: Do a better job at implementing default_feedback. It needs to be on a per/component basis. Maybe  the component can look for a default_feedback attribute on the control and use that to register auto functions for feedback.
class Control(ControlBase):
    """This is the actual control Class. Inherit from this class when building your own controls if necessary. This is also the class from which the included controls are derived."""
    def __init__(self, name, channel, identifier, playable=False, status=MIDI_STATUS.NOTE_ON_STATUS, feedback=False, feedback_process=None, default_color='Default', blackout_color='Off', skin=None):
        super(Control, self).__init__(name, channel, identifier, status, playable)
        self._skin = skin
        """Skin for this controller. A skin holds attributes on how to draw a particular "color" to the device. By color, I mean what midi message to send to the device to achieve the desired look, ie... LEDs, RGB leds, etc """
        self.feedback: bool = feedback
        """The attribute defines whether or not the control should send feedback to itself. This is useful for lighting pad, or LEDs back to controller."""
        self.feedback_process = feedback_process
        """This is a function that processes the feedback before it is sent back."""
        self.default_color: SkinColor = default_color
        """This is the default color for the control. When it is activated, it will be set to this color if skin and default_color are provided."""
        self.blackout_color = blackout_color
        """This is the blackout color for the control. Can be called to blackout the control."""
        self.registry.register_control(self)

    def _on_value(self, event):
        """This function is called whenever a value from the control is sent.
            Example. If you move a knob on a CC#37, the values for that control change are sent as event arguments to this function.
            This is useful for emitting your own custom events for a control, or reacting to the raw data sent by the control.
        """
        # self.notify_listeners('value', event)

    def _initialize(self):
        """Initializes the control to its default color"""
        self.set_light(self.default_color)

    def activate(self):
        """
        activate() is called by the component when the component is activating. 
        It registers the control with the Global Control Registry, and subscribes to its own "value" events, that is, when a midiMsg comes from this control.
        """

        self._initialize()
        self.event_object.subscribe("{}.value".format(self.name), self._on_value)
        self.registry.activate_control(self)
        self.isChanged('active', True)

    def deactivate(self):
        """
        deactivate() is called by the component when the component is deactivating.
        It unregisters the control from the Global Control Registry and unsubscribes from its own "value" events.
        """
        self.reset()
        self.event_object.unsubscribe("{}.value".format(self.name), self._on_value)
        self.registry.deactivate_control(self)
        self.isChanged('active', False)

    def set_light(self, value, *a, **k):
        """
        Method to send a color to the control by "value". A skin must be provided to the control for set_light to function.
        A skin is a class with color members. Each color member has a draw method. The draw method contains the code to send color messages to the MIDI device.
        """
        try:
            if self._skin:
                color: SkinColor = getattr(self._skin, value)
                color.draw(self, *a, **k)
        except AttributeError:
            print(f'Skin Color: {self._skin}.{value} Not found')

    def reset(self):
        """Resets the control to its default color"""
        self.set_light(self.default_color)
    
    def __del__(self):
        self.registry.unregister_control(self)
    
    def blackout(self):
        """Turns the control off"""
        self.set_light(self.blackout_color)
