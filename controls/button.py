# from ..util.midi import MIDI_STATUS
from ..util.midi import MIDI_STATUS
from ..api.fl_class import flMidiMsg
from .control import Control

class ButtonControl(Control):
    """
    Represents a button control for a MIDI controller.

    Args:
        name (str): The name of the button control.
        channel (int): The MIDI channel of the button control.
        identifier (int): The MIDI identifier of the button control.
        playable (bool, optional): Whether the button control is playable. Defaults to False.
        status (int, optional): The MIDI status of the button control. Defaults to MIDI_STATUS.NOTE_ON_STATUS.
        feedback (bool, optional): Whether the button control provides feedback. Defaults to False.
        feedback_process (callable, optional): The feedback process function for the button control. Defaults to None.
        default_color (str, optional): The default color of the button control. Defaults to 'Default'.
        blackout_color (str, optional): The blackout color of the button control. Defaults to 'Off'.
        skin (any, optional): The skin of the button control. Defaults to None.
        hold_time (int, optional): The hold time in milliseconds for the button control. Defaults to 10.

    Attributes:
        isToggled (bool): Whether the button control is toggled.
        isHold (bool): Whether the button control is being held.
        isPressed (bool): Whether the button control is currently pressed.

    """
    class Events:
        """
        Represents the events generated by the Button control.
        """
        TOGGLED: str = 'toggled'
        """Button toggled event."""
        PRESSED: str = 'pressed'
        """Button pressed event."""
        RELEASED: str = 'released'
        """Button released event."""
        HOLD: str = 'hold'
        """Button hold event."""
    @staticmethod
    def generate_button_events(status: int, event_data: flMidiMsg) -> dict[str: any]:
        """
        Generates button events based on the MIDI message status.

        Args:
            on_msg_status (int): The MIDI status for turning the button on.
            off_msg_status (int): The MIDI status for turning the button off.
            event_data (flMidiMsg): The MIDI message data.

        Returns:
            dict[str: any]: A dictionary containing the generated button events.

        """
        events: dict[str: any] = dict()
        # generate button events for notes
        if status == MIDI_STATUS.NOTE_ON_STATUS:
            if flMidiMsg.isNoteOn(event_data):
                events[ButtonControl.Events.TOGGLED] = None
                events[ButtonControl.Events.PRESSED] = True
            elif flMidiMsg.isNoteOff(event_data):
                events[ButtonControl.Events.PRESSED] = False
                events[ButtonControl.Events.RELEASED] = True

        # generate button events for CC
        elif status == MIDI_STATUS.CC_STATUS:
            if event_data.data2 > 0:
                events[ButtonControl.Events.TOGGLED] = None
                events[ButtonControl.Events.PRESSED] = True
            elif event_data.data2 == 0:
                events[ButtonControl.Events.PRESSED] = False
                events[ButtonControl.Events.RELEASED] = True
        return events

    def __init__(
        self, name, channel, identifier,
        playable=False,
        status=MIDI_STATUS.NOTE_ON_STATUS,
        feedback=False, 
        feedback_process=None, 
        default_color='DEFAULT', 
        blackout_color='OFF', 
        skin=None,
        hold_time=10, *a, **k):
        """
        Initializes a new instance of the ButtonControl class.

        Args:
            name (str): The name of the button control.
            channel (int): The MIDI channel of the button control.
            identifier (int): The MIDI identifier of the button control.
            playable (bool, optional): Whether the button control is playable. Defaults to False.
            status (int, optional): The MIDI status of the button control. Defaults to MIDI_STATUS.NOTE_ON_STATUS.
            feedback (bool, optional): Whether the button control provides feedback. Defaults to False.
            feedback_process (callable, optional): The feedback process function for the button control. Defaults to None.
            default_color (str, optional): The default color of the button control. Defaults to 'Default'.
            blackout_color (str, optional): The blackout color of the button control. Defaults to 'Off'.
            skin (any, optional): The skin of the button control. Defaults to None.
            hold_time (int, optional): The hold time in milliseconds for the button control. Defaults to 10.

        """
        super().__init__(name, channel, identifier, playable, status,
                         feedback, feedback_process, default_color, blackout_color, skin)
        self.on_color = "On"
        self.default_feedback: bool = False
        self._toggled = False
        self._pressed = False
        self._hold = False
        self._hold_counter = 0
        self.hold_time = hold_time

    @property
    def isToggled(self):
        """
        bool: Whether the button control is toggled.
        """
        return self._toggled

    def _on_idle(self):
        """
        Handles the idle event of the button control.
        """
        if self._pressed:
            self.hold_counter += 1
            if self.hold_counter > self.hold_time:
                if self.isChanged('_hold', True):
                    self._set_hold(True)
        else:
            self.hold_counter = 0
            if self.isChanged('_hold', False):
                self._set_hold(False)

    def _set_hold(self, hold):
        """
        Sets the hold state of the button control.

        Args:
            hold (bool): Whether the button control is being held.

        """
        self._hold = hold
        self.notify('hold', self._hold)

    @property
    def isHold(self) -> bool:
        """
        bool: Whether the button control is being held.
        """
        return self._hold

    def activate(self):
        """
        Activates the button control.

        Returns:
            bool: True if the activation is successful, False otherwise.

        """
        self.event_object.subscribe('idle', self._on_idle)
        return super().activate()

    @property
    def isPressed(self) -> bool:
        """
        bool: Whether the button control is currently pressed.
        """
        return self._pressed

    def _set_toggled(self):
        """
        Toggles the state of the button control.
        """
        self._toggled = not self._toggled
        self.notify(ButtonControl.Events.TOGGLED, self._toggled)

    def _set_pressed(self, value):
        """
        Sets the pressed state of the button control.

        Args:
            value (bool): Whether the button control is pressed.

        """
        self._pressed = value
        self.notify('pressed', self._pressed)

    def _set_released(self, value):
        """
        Sets the released state of the button control.

        Args:
            value (bool): Whether the button control is released.

        """
        self._released = value
        self.notify('released', self._released)
    def _show_default_feedback(self, event_data: flMidiMsg):
        """
        Shows the default feedback for the button control.

        Args:
            event_data (flMidiMsg): The MIDI message data.

        """
        if self.default_feedback:
            if self.status == MIDI_STATUS.NOTE_ON_STATUS:
                if flMidiMsg.isNoteOn(event_data):
                    self.set_light(self.on_color)
                elif flMidiMsg.isNoteOff(event_data):
                    self.set_light(self.default_color)

            # generate button events for CC
            elif self.status == MIDI_STATUS.CC_STATUS:
                if event_data.data2 > 0:
                    self.set_light(self.on_color)
                elif event_data.data2 == 0:
                    self.set_light(self.default_color)

    def _on_value(self, event_data):
        """
        Handles the value change event of the button control.

        Args:
            event_data (flMidiMsg): The MIDI message data.

        """
        self._show_default_feedback(event_data)
        events = ButtonControl.generate_button_events(self.status, event_data)
        for event in events:
            setattr(self, '_{}'.format(event), events[event])
            self.notify(event, events[event])

    def __str__(self) -> str:
        return f"{self.name} {self.status}:{self.channel}:{self.identifier}"

    def __repr__(self) -> str:
        return f"{self.name} {self.status}:{self.channel}:{self.identifier}"
